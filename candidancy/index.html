<!DOCTYPE html>
<html lang="en">
<head>
  <title>
    Candidancy Exam Proposal
  </title>
  <script src="http://www.cs.columbia.edu/~theofilos/js/jquery-1.11.2.min.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta charset="utf-8">
  <link rel="stylesheet" href="http://www.cs.columbia.edu/~theofilos/css/bootstrap.css" media="screen" type="text/css">
  <link rel="stylesheet" href="http://www.cs.columbia.edu/~theofilos/css/font-awesome.min.css" type="text/css">
  <link rel="stylesheet" href="http://www.cs.columbia.edu/~theofilos/css/plain.css" type="text/css">
  <link rel="shortcut icon" href="http://www.cs.columbia.edu/~theofilos/fig/favicon.ico">
</head>
<body>

<div class="container">
    <div class="page-header" id="banner">
        <div class="row">
            <div class="col-lg-12">
                <h1>
                    <center>
                    Compiler-Assisted Defenses Against Memory Exploitation
                </center>
                </h1>
            </div>
        </div>
    </div>
    <div id="publications">
        <div class="paperlist">
            <ol>
							<!--<h2>Control Flow Integrity (CFI)</h2>-->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/ccfi.pdf"
                            target="_blank">
                            CCFI:
                            Cryptographically Enforced Control Flow
                            Integrity (CCS 2015)
                        </a>
                    </div>
                    Mashtizadeh, A. J., Bittau, A., Boneh, D., & Mazières, D.
                    (2015, October).
                    In Proceedings of the 22nd ACM SIGSAC
                    Conference on Computer and Communications Security (pp.
                    941-951). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Control flow integrity (CFI) restricts jumps and
                            branches within a program to prevent attackers
                            from executing arbitrary code in vulnerable
                            programs. However, traditional CFI still offers
                            attackers too much freedom to chose between valid
                            jump targets, as seen in recent attacks.
                            <br></br>
                            We present a new approach to CFI based on
                            cryptographic message authentication codes (MACs).
                            Our approach, called cryptographic CFI (CCFI),
                            uses MACs to protect control flow elements such as
                            return addresses, function pointers, and vtable
                            pointers. Through dynamic checks, CCFI enables
                            much finer-grained classification of sensitive
                            pointers than previous approaches, thwarting all
                            known attacks and resisting even attackers with
                            arbitrary access to program memory.
                            <br></br>
                            We implemented CCFI in Clang/LLVM, taking
                            advantage of recently available cryptographic CPU
                            instructions (AES-NI). We evaluate our system on
                            several large software packages (including nginx,
                            Apache and memcache) as well as all their
                            dependencies. The cost of protection ranges from a
                            3--18% decrease in server request rate. We also
                            expect this overhead to shrink as Intel improves
                            the performance AES-NI.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/safedispatch.pdf"
                            target="_blank">
                            SAFEDISPATCH: Securing C++ virtual calls from
                            memory corruption attacks (NDSS 2014)
                        </a>
                    </div>
                            Jang, D., Tatlock, Z., & Lerner, S. (2014).
                            In Symposium on Network
                            and Distributed System Security (NDSS).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Several defenses have increased the cost of
                            traditional,
                            low-level attacks that corrupt control data, e.g.
                            return
                            addresses saved on the stack, to compromise
                            program execution.
                            In response, creative adversaries have begun
                            circumventing
                            these defenses by exploiting programming errors to
                            manipulate
                            pointers to virtual tables, or vtables, of C++
                            objects. These attacks
                            can hijack program control flow whenever a virtual
                            method of
                            a corrupted object is called, potentially allowing
                            the attacker to
                            gain complete control of the underlying system. In
                            this paper we
                            present SAFEDISPATCH, a novel defense to prevent
                            such vtable
                            hijacking by statically analyzing C++ programs and
                            inserting
                            sufficient runtime checks to ensure that control
                            flow at virtual
                            method call sites cannot be arbitrarily influenced
                            by an attacker.
                            We implemented SAFEDISPATCH as a Clang++/LLVM
                            extension,
                            used our enhanced compiler to build a vtable-safe
                            version of
                            the Google Chromium browser, and measured the
                            performance
                            overhead of our approach on popular browser
                            benchmark suites.
                            By carefully crafting a handful of optimizations,
                            we were able to
                            reduce average runtime overhead to just 2.1%

                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/forwardcfi.pdf"
                            target="_blank">
                            Enforcing Forward-Edge Control-Flow Integrity in
                            GCC & LLVM (USENIX 2014)
                        </a>
                    </div>
                    Tice, C., Roeder, T., Collingbourne, P., Checkoway, S.,
                    Erlingsson, Ú., Lozano, L., & Pike, G. (2014, August).
                    In USENIX Security Symposium
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Constraining dynamic control transfers is a common
                            technique for mitigating software vulnerabilities.
                            This defense has been widely and successfully used
                            to protect return addresses and stack data; hence,
                            current attacks instead typically corrupt vtable
                            and function pointers to subvert a forward edge
                            (an indirect jump or call) in the control-flow
                            graph. Forward edges can be protected using
                            Control-Flow Integrity (CFI) but, to date, CFI
                            implementations have been research prototypes,
                            based on impractical assumptions or ad hoc,
                            heuristic techniques. To be widely adoptable, CFI
                            mechanisms must be integrated into production
                            compilers and be compatible with
                            software-engineering aspects such as incremental
                            compilation and dynamic libraries.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/cfr.pdf"
                            target="_blank">
                        Control-flow restrictor: compiler-based CFI for iOS
                        (ACSAC 2013)
                        </a>
                    </div>
                    Pewny, J., & Holz, T. (2013, December). Control-flow
                    restrictor
                    In Proceedings of
                    the 29th Annual Computer Security Applications Conference
                    (pp. 309-318). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Runtime attacks that exploit software
                            vulnerabilities are still an important concern
                            nowadays. Even smartphone operating systems such
                            as Apple's iOS are affected by such attacks since
                            the system is implemented in Objective-C, a
                            programming language that enables attacks such as
                            buffer overflows. As a generic protection
                            technique against a whole class of attacks,
                            control-flow integrity (CFI) offers some
                            interesting properties. Recent work demonstrated
                            that CFI can be implemented on iOS by patching the
                            binary during the loading process and adding an
                            instrumentation layer that enforces CFI during
                            runtime. However, this approach is of little
                            practical value since it requires a jailbroken
                            device, which hinders wide employment.
                            Furthermore, binary patching has a certain
                            performance impact.
                            <br></br>
                            In this paper, we show how CFI can be implemented
                            directly within a compiler, making the approach
                            widely deployable on all kinds of iOS devices. We
                            extend the LLVM compiler and add our CFI
                            enforcement approach during the compilation phase
                            of a given app. An empirical evaluation shows that
                            the size and performance overhead is reasonable.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/strato.pdf"
                            target="_blank">
                            Strato: A Retargetable Framework for Low-Level
                            Inlined-Reference Monitors (USENIX 2013)
                        </a>
                    </div>
                    Zeng, B., Tan, G., & Erlingsson, Ú. (2013, August).
                    In Usenix Security (pp.
                    369-382).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Low-level Inlined Reference Monitors (IRM) such as
                            control-flow integrity and software-based fault
                            isolation can foil numerous software attacks.
                            Conventionally, those IRMs are implemented through
                            binary rewriting or transformation on equivalent
                            low-level programs that are tightly coupled with a
                            specific Instruction Set Architecture (ISA).
                            Resulting implementations have poor
                            retargetability to different ISAs. This paper
                            introduces an IRM-implementation framework at a
                            compiler intermediate-representation (IR) level.
                            The IR-level framework enables easy
                            retargetability to different ISAs, but raises the
                            challenge of how to preserve security at the low
                            level, as the compiler backend might invalidate
                            the assumptions at the IR level. We propose a
                            constraint language to encode the assumptions and
                            check whether they still hold after the backend
                            transformations and optimizations. Furthermore, an
                            independent verifier is implemented to validate
                            the security of low-level code. We have
                            implemented the framework inside LLVM to enforce
                            the policy of control-flow integrity and data
                            sandboxing for both reads and writes. Experimental
                            results demonstrate that it incurs modest runtime
                            overhead of 19.90% and 25.34% on SPECint2000
                            programs for x86-32 and x86-64, respectively
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/kguard.pdf"
                            target="_blank">
                    kGuard: Lightweight Kernel Protection
                    against Return-to-User Attacks (USENIX 2012)
                        </a>
                    </div>
                    Kemerlis, V. P., Portokalidis, G., & Keromytis, A. D.
                    (2012, August).
                    In USENIX Security
                    Symposium (pp. 459-474).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Return-to-user (ret2usr) attacks exploit the
                            operating system kernel, enabling local users to
                            hijack privileged execution paths and execute
                            arbitrary code with elevated privileges. Current
                            defenses have proven to be inadequate, as they
                            have been repeatedly circumvented, incur
                            considerable overhead, or rely on extended hyperv
                            sors and special hardware features. We present
                            kGuard, a compiler plugin that augments the kernel
                            with compact inline guards, which prevent ret2usr
                            with low performance and space overhead. kGuard
                            can be used with any operating system that
                            features a weak separation between kernel and user
                            space, requires no modifications to the OS, and is
                            applicable to both 32- and 64-bit architectures.
                            Our evaluation demonstrates that Linux kernels
                            compiled with kGuard become impervious to a
                            variety of control-flow hijacking exploits. kGuard
                            exhibits lower overhead than previous work,
                            imposing on average an overhead of 11.4% on system
                            call and I/O latency on x86 OSs, and 10.3% on
                            x86-64. The size of a kGuard-protected kernel
                            grows between 3.5% and 5.6%, due to the inserted
                            checks, while the impact on real-life applications
                            is minimal (≤1%).
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="https://www.usenix.org/legacy/event/sec09/tech/full_papers/criswell.pdf"
                            target="_blank">
											Memory Safety for Low-Level Software/Hardware
											Interactions (USENIX 2009)
                        </a>
											</div>
											Criswell, J., Geoffray, N., & Adve, V. S. (2009, August).
										 	In USENIX Security Symposium (pp. 83-100).
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													Systems that enforce memory safety for today’s
													operating
													system kernels and other system software do not
													account for the behavior of low-level
													software/hardware
													interactions such as memory-mapped I/O, MMU
													configuration,
													and context switching. Bugs in such low-level
													interactions can lead to violations of the memory
													safety
													guarantees provided by a safe execution environment
													and
													can lead to exploitable vulnerabilities in system
													software.
													In this work, we present a set of program analysis
													and
													run-time instrumentation techniques that ensure that
													errors
													in these low-level operations do not violate the
													assumptions
													made by a safety checking system. Our design
													introduces a small set of abstractions and interfaces
													for manipulating processor state, kernel stacks,
													memory
													mapped I/O objects, MMU mappings, and self modifying
													code to achieve this goal, without moving resource
													allocation and management decisions out of the
													kernel.
													We have added these techniques to a compiler-based
													virtual
													machine called Secure Virtual Architecture (SVA),
													to which the standard Linux kernel has been ported
													previously.
													Our design changes to SVA required only an additional
													100 lines of code to be changed in this kernel. Our
													experimental results show that our techniques prevent
													reported
													memory safety violations due to low-level Linux
													operations and that these violations are not
													prevented by
													SVA without our techniques. Moreover, the new
													techniques
													in this paper introduce very little overhead over
													and above the existing overheads of SVA. Taken
													together,
													these results indicate that it is clearly worthwhile
													to add
													these techniques to an existing memory safety system.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://sva.cs.illinois.edu/pubs/KCoFI-Oakland-2014.pdf"
														target="_blank">
											KCoFI: Complete control-flow integrity for commodity
											operating system kernels (S&P 2014)
                        </a>
											</div>
											Criswell, J., Dautenhahn, N., & Adve, V. (2014, May).
											In Security and Privacy (SP),
											2014 IEEE Symposium on (pp. 292-307). IEEE.
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													We present a new system, KCoFI, that is the first we
													know of to provide complete Control-Flow Integrity
													protection for commodity operating systems without
													using heavyweight complete memory safety. Unlike
													previous systems, KCoFI protects commodity operating
													systems from classical control-flow hijack attacks,
													return-to-user attacks, and code segment modification
													attacks. We formally verify a subset of KCoFI's
													design by modeling several features in small-step
													semantics and providing a partial proof that the
													semantics maintain control-flow integrity. The model
													and proof account for operations such as page table
													management, trap handlers, context switching, and
													signal delivery. Our evaluation shows that KCoFI
													prevents all the gadgets found by an open-source
													Return Oriented Programming (ROP) gadget-finding tool
													in the FreeBSD kernel from being used, it also
													reduces the number of indirect control-flow targets
													by 98.18%. Our evaluation also shows that the
													performance impact of KCoFI on web server bandwidth
													is negligible while file transfer bandwidth using
													OpenSSH is reduced by an average of 13%, and at worst
													27%, across a wide range of file sizes. Postmark, an
													extremely file-system intensive benchmark, shows 2x
													overhead. Where comparable numbers are available, the
													overheads of KCoFI are far lower than heavyweight
													memory-safety techniques.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/wit.pdf"
                            target="_blank">
                    Preventing memory error exploits with WIT (S&P 2008)
                        </a>
                    </div>
                    Akritidis, P., Cadar, C., Raiciu, C., Costa, M., & Castro,
                    M. (2008, May)
                    In Security and Privacy, 2008. SP 2008. IEEE Symposium on
                    (pp. 263-277). IEEE.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Attacks often exploit memory errors to gain
                            control over the execution of vulnerable programs.
                            These attacks remain a serious problem despite
                            previous research on techniques to prevent them.
                            We present write integrity testing (WIT), a new
                            technique that provides practical protection from
                            these attacks. WIT uses points-to analysis at
                            compile time to compute the control-flow graph and
                            the set of objects that can be written by each
                            instruction in the program. Then it generates code
                            instrumented to prevent instructions from
                            modifying objects that are not in the set computed
                            by the static analysis, and to ensure that
                            indirect control transfers are allowed by the
                            control-flow graph. To improve coverage where the
                            analysis is not precise enough, WIT inserts small
                            guards between the original program objects. We
                            describe an efficient implementation with
                            optimizations to reduce space and time overhead.
                            This implementation can be used in practice
                            because it compiles C and C++ programs without
                            modifications, it has high coverage with no false
                            positives, and it has low overhead. WIT's average
                            runtime overhead is only 7% across a set of CPU
                            intensive benchmarks and it is negligible when IO
                            is the bottleneck.
                        </div>
                    </span>
                </div>
                </li>
								<!-- <h2>Memory Safety</h2> -->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/memsafe.pdf"
                            target="_blank">
                            MemSafe: Ensuring the Spatial and Temporal Memory
                            Safety of C at Runtime (SPE 2013)
                        </a>
                    </div>
                    Simpson, M. S., & Barua, R. K. (2013).
                    Software: Practice and Experience, 43(1), 93-128.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Memory access violations are a leading source of
                            unreliability in C programs. As evidence of this
                            problem, a variety of methods exist that retrofit
                            C with software checks to detect memory errors at
                            runtime. However, these methods generally suffer
                            from one or more drawbacks including the inability
                            to detect all errors, the use of incompatible
                            metadata, the need for manual code modifications,
                            and high runtime overheads. This paper presents a
                            compiler analysis and transformation for ensuring
                            the memory safety of C called MemSafe. MemSafe
                            makes several novel contributions that improve
                            upon previous work and lower the cost of safety.
                            These include (i) a method for modeling temporal
                            errors as spatial errors, (ii) a metadata
                            representation that combines features of both
                            object-based and pointer-based approaches, and
                            (iii) a dataflow representation that simplifies
                            optimizations for removing unneeded checks.
                            MemSafe is capable of detecting real errors with
                            lower overheads than previous efforts.
                            Experimental results show that MemSafe detects all
                            memory errors in six programs with known
                            violations as well as two large and widely used
                            open source applications. Finally, MemSafe ensures
                            complete safety with an average overhead of 88% on
                            30 programs commonly used for evaluating the
                            performance of error detection tools. Copyright ©
                            2012 John Wiley & Sons, Ltd.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/cets.pdf"
                            target="_blank">
                    CETS: compiler enforced temporal safety for C (ISMM 10)
                        </a>
                    </div>
                    Nagarakatte, S., Zhao, J., Martin, M. M., & Zdancewic, S.
                    (2010, June)
                    In ACM Sigplan Notices (Vol. 45, No. 8, pp. 31-40).
                    ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Temporal memory safety errors, such as dangling
                            pointer dereferences and double frees, are a
                            prevalent source of software bugs in unmanaged
                            languages such as C. Existing schemes that attempt
                            to retrofit temporal safety for such languages
                            have high runtime overheads and/or are incomplete,
                            thereby limiting their effectiveness as debugging
                            aids. This paper presents CETS, a compile-time
                            transformation for detecting all violations of
                            temporal safety in C programs. Inspired by
                            existing approaches, CETS maintains a unique
                            identifier with each object, associates this
                            metadata with the pointers in a disjoint metadata
                            space to retain memory layout compatibility, and
                            checks that the object is still allocated on
                            pointer dereferences. A formal proof shows that
                            this is sufficient to provide temporal safety even
                            in the presence of arbitrary casts if the program
                            contains no spatial safety violations. Our CETS
                            prototype employs both temporal check removal
                            optimizations and traditional compiler
                            optimizations to achieve a runtime overhead of
                            just 48% on average. When combined with a
                            spatial-checking system, the average overall
                            overhead is 116% for complete memory safety
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/softbound.pdf"
                            target="_blank">
                    SoftBound: highly compatible and complete
                    spatial memory safety for C (PLDI 2009)
                        </a>
                    </div>
                    Nagarakatte, S., Zhao, J., Martin, M. M., & Zdancewic, S.
                    (2009, June).
                    In ACM Sigplan Notices (Vol.
                    44, No. 6, pp. 245-258). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            The serious bugs and security vulnerabilities
                            facilitated by C/C++'s lack of bounds checking are
                            well known, yet C and C++ remain in widespread
                            use. Unfortunately, C's arbitrary pointer
                            arithmetic, conflation of pointers and arrays, and
                            programmer-visible memory layout make retrofitting
                            C/C++ with spatial safety guarantees extremely
                            challenging. Existing approaches suffer from
                            incompleteness, have high runtime overhead, or
                            require non-trivial changes to the C source code.
                            Thus far, these deficiencies have prevented
                            widespread adoption of such techniques.
                            <br></br>
                            This paper proposes SoftBound, a compile-time
                            transformation for enforcing spatial safety of C.
                            Inspired by HardBound, a previously proposed
                            hardware-assisted approach, SoftBound similarly
                            records base and bound information for every
                            pointer as disjoint metadata. This decoupling
                            enables SoftBound to provide spatial safety
                            without requiring changes to C source code. Unlike
                            HardBound, SoftBound is a software-only approach
                            and performs metadata manipulation only when
                            loading or storing pointer values. A formal proof
                            shows that this is sufficient to provide spatial
                            safety even in the presence of arbitrary casts.
                            SoftBound's full checking mode provides complete
                            spatial violation detection with 67% runtime
                            overhead on average. To further reduce overheads,
                            SoftBound has a store-only checking mode that
                            successfully detects all the security
                            vulnerabilities in a test suite at the cost of
                            only 22% runtime overhead on average.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/jk.pdf"
                            target="_blank">
											Backwards-Compatible Bounds Checking for Arrays and
											Pointers in C Programs (1997)
                        </a>
											</div>
											Jones, R. W., & Kelly, P. H. (1997, May).
											In AADEBUG (Vol. 97, pp. 13-26).
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													This paper presents a new approach to enforcing array
													bounds and pointer checking in the C language.
													Checking is rigorous in the sense that the result of
													pointer arithmetic must refer to the same object as
													the original pointer (this object is sometimes
													called the 'intended referent'). The novel aspect
													of this work is that checked code can inter-operate
													without restriction with unchecked code, without
													interface problems, with some e ective checking, and
													without false alarms. This backwards compatibility"
													property allows the overheads of checking to be con
													ned to suspect modules, and also facilitates the use
													of libraries for which source code is not available.
													The paper describes the scheme, its prototype
													implementation (as an extension to the GNU C
													compiler), presents experimental results to evaluate
													its e ectiveness, and discusses performance issues
													and the e ectiveness of some simple optimisations
                        </div>
                    </span>
                </div>
								</li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/bbc.pdf"
                            target="_blank">
                    Baggy Bounds Checking: An Efficient and
                    Backwards-Compatible Defense against Out-of-Bounds Errors
                    (USENIX 2009)
                        </a>
                    </div>
                    Akritidis, P., Costa, M., Castro, M., & Hand, S. (2009,
                    August)
                    In USENIX Security Symposium (pp. 51-66).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Attacks that exploit out-of-bounds errors in C and
                            C++ programs are still prevalent despite many
                            years of research on bounds checking. Previous
                            backwards compatible bounds checking techniques,
                            which can be applied to unmodified C and C++
                            programs, maintain a data structure with the
                            bounds for each allocated object and perform
                            lookups in this data structure to check if
                            pointers remain within bounds. This data structure
                            can grow large and the lookups are expensive.
                            <br></br>
                            In this paper we present a backwards compatible
                            bounds checking technique that substantially
                            reduces performance overhead. The key insight is
                            to constrain the sizes of allocated memory regions
                            and their alignment to enable efficient bounds
                            lookups and hence efficient bounds checks at
                            runtime. Our technique has low overhead in
                            practice--only 8% throughput decrease for Apache--
                            and is more than two times faster than the fastest
                            previous technique and about five times
                            faster--using less memory--than recording object
                            bounds using a splay tree.
                        </div>
                    </span>
                </div>
								</li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://llvm.org/pubs/2006-05-12-PLDI-SAFECode.pdf"
                            target="_blank">
											SAFECode:
											enforcing alias analysis for weakly typed languages
											(PLDI 2006)
                        </a>
											</div>
											Dhurjati, D., Kowshik, S., & Adve, V. (2006).
											ACM
											SIGPLAN Notices, 41(6), 144-157.
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													Static analysis of programs in weakly typed languages
													such as C and C++ is generally not sound because of
													possible memory errors due to dangling pointer
													references, uninitialized pointers, and array bounds
													overflow. We describe a compilation strategy for
													standard C programs that guarantees that aggressive
													interprocedural pointer analysis (or less precise
													ones), a call graph, and type information for a
													subset of memory, are never invalidated by any
													possible memory errors. We formalize our approach as
													a new type system with the necessary run-time checks
													in operational semantics and prove the correctness of
													our approach for a subset of C. Our semantics provide
													the foundation for other sophisticated static
													analyses to be applied to C programs with a guarantee
													of soundness. Our work builds on a previously
													published transformation called Automatic Pool
													Allocation to ensure that hard-to-detect memory
													errors (dangling pointer references and certain array
													bounds errors) cannot invalidate the call graph,
													points-to information or type information. The key
													insight behind our approach is that pool allocation
													can be used to create a run-time partitioning of
													memory that matches the compile-time memory
													partitioning in a points-to graph, and efficient
													checks can be used to isolate the run-time
													partitions. Furthermore, we show that the sound
													analysis information enables static checking
													techniques that eliminate many run-time checks. Our
													approach requires no source code changes, allows
													memory to be managedexplicitly, and does not use
													meta-data on pointers or individual tag bits for
													memory. Using several benchmark s and system codes,
													we show experimentally that the run-time overheads
													are low (less than 10% in nearly all cases and 30% in
													the worst case we have seen).We also show the
													effectiveness of static analyses in eliminating
													run-time checks.
                        </div>
                    </span>
                </div>
                </li>
								<!--
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/eff_back.pdf"
                            target="_blank">
                    An efficient
                    and backwards-compatible transformation to ensure memory
                    safety of C programs (SIGSOFT 2004)
                        </a>
                    </div>
                    Xu, W., DuVarney, D. C., & Sekar, R. (2004).
                    ACM SIGSOFT Software Engineering
                    Notes, 29(6), 117-126.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Memory-related errors, such as buffer overflows
                            and dangling pointers, remain one of the principal
                            reasons for failures of C programs. As a result, a
                            number of recent research efforts have focused on
                            the problem of dynamic detection of memory errors
                            in C programs. However, existing approaches suffer
                            from one or more of the following problems:
                            inability to detect all memory errors (e.g.,
                            Purify), requiring non-trivial modifications to
                            existing C programs (e.g., Cyclone), changing the
                            memory management model of C to use garbage
                            collection (e.g., CCured), and excessive
                            performance overheads. In this paper, we present a
                            new approach that addresses these problems. Our
                            approach operates via source code transformation
                            and combines efficient data-structures with
                            simple, localized optimizations to obtain good
                            performance.
                        </div>
                    </span>
                </div>
								</li>
								-->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/lattner_safety.pdf"
                            target="_blank">
                    Memory safety without runtime checks or garbage
                    collection. (LCTES 2003)
                        </a>
                    </div>
                    Dhurjati, D., Kowshik, S., Adve, V., & Lattner, C. (2003).
                    ACM SIGPLAN Notices, 38(7), 69-80.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Traditional approaches to enforcing memory safety
                            of programs rely heavily on runtime checks of
                            memory accesses and on garbage collection, both of
                            which are unattractive for embedded applications.
                            The long-term goal of our work is to enable 100%
                            static enforcement of memory safety for embedded
                            programs through advanced compiler techniques and
                            minimal semantic restrictions on programs. The key
                            result of this paper is a compiler technique that
                            ensures memory safety of dynamically allocated
                            memory without programmer annotations, runtime
                            checks, or garbage collection, and works for a
                            large subclass of type-safe C programs. The
                            technique is based on a fully automatic pool
                            allocation (i.e., region-inference) algorithm for
                            C programs we developed previously, and it ensures
                            safety of dynamically allocated memory while
                            retaining explicit deallocation of individual
                            objects within regions (to avoid garbage
                            collection). For a diverse set of embedded C
                            programs (and using a previous technique to avoid
                            null pointer checks), we show that we are able to
                            statically ensure the safety of pointer and
                            dynamic memory usage in all these programs. We
                            also describe some improvements over our previous
                            work in static checking of array accesses.
                            Overall, we achieve 100% static enforcement of
                            memory safety without new language syntax for a
                            significant subclass of embedded C programs, and
                            the subclass is much broader if array bounds
                            checks are ignored. Overall, these techniques
                            greatly expand the class of embedded programs for
                            which 100% static enforcement of memory safety is
                            possible, and furthermore can be achieved without
                            new language support.
                        </div>
                    </span>
                </div>
                </li>
								<!--<h2>Data Integrity</h2>-->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/dfi.pdf"
                            target="_blank">
                            Securing software by enforcing data-flow integrity
                            (OSDI 2006)
                        </a>
                    </div>
                    Castro, M., Costa, M., & Harris, T. (2006, November).
                    In
                    Proceedings of the 7th symposium on Operating systems
                    design and implementation (pp. 147-160). USENIX
                    Association.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Software attacks often subvert the intended
                            data-flow in a vulnerable program. For example,
                            attackers exploit buffer overflows and format
                            string vulnerabilities to write data to unintended
                            locations. We present a simple technique that
                            prevents these attacks by enforcing data-flow
                            integrity. It computes a data-flow graph using
                            static analysis, and it instruments the program to
                            ensure that the flow of data at runtime is allowed
                            by the data-flow graph. We describe an efficient
                            implementation of data-flow integrity enforcement
                            that uses static analysis to reduce
                            instrumentation overhead. This implementation can
                            be used in practice to detect a broad class of
                            attacks and errors because it can be applied
                            automatically to C and C++ programs without
                            modifications, it does not have false positives,
                            and it has low overhead.
                        </div>
                    </span>
                </div>
								</li>
					<!--
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/dsr.pdf"
                            target="_blank">
                        Data space randomization (DIMVA 2008)
                        </a>
                    </div>
                        Bhatkar, S., & Sekar, R. (2008).
                        In Detection of Intrusions and Malware,
                        and Vulnerability Assessment (pp. 1-22). Springer
                        Berlin Heidelberg.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Over the past several years, US-CERT advisories,
                            as well as most critical updates from software
                            vendors, have been due to memory corruption
                            vulnerabilities such as buffer overflows, heap
                            overflows, etc. Several techniques have been
                            developed to defend against the exploitation of
                            these vulnerabilities, with the most promising
                            defenses being based on randomization. Two
                            randomization techniques have been explored so
                            far: address space randomization (ASR) that
                            randomizes the location of objects in virtual
                            memory, and instruction set randomization (ISR)
                            that randomizes the representation of code. We
                            explore a third form of randomization called data
                            space randomization (DSR) that randomizes the
                            representation of data stored in program memory.
                            Unlike ISR, DSR is effective against non-control
                            data attacks as well as code injection attacks.
                            Unlike ASR, it can protect against corruption of
                            non-pointer data as well as pointer-valued data.
                            Moreover, DSR provides a much higher range of
                            randomization (typically 232for 32-bit data) as
                            compared to ASR. Other interesting aspects of DSR
                            include (a) it does not share a weakness common to
                            randomization-based defenses, namely,
                            susceptibility to information leakage attacks, and
                            (b) it is capable of detecting some exploits that
                            are missed by full bounds-checking techniques,
                            e.g., some of the overflows from one field of a
                            structure to the next field. Our implementation
                            results show that with appropriate design choices,
                            DSR can achieve a performance overhead in the
                            range of 5% to 30% for a range of programs.
                        </div>
                    </span>
                </div>
								</li>
							-->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/invderef.pdf"
                            target="_blank">
                            Protecting C programs from attacks via invalid
                            pointer dereferences (SIGSOFT 2003)
                        </a>
                    </div>
                    Yong, S. H., & Horwitz, S. (2003, September).
                    In
                    ACM SIGSOFT Software Engineering Notes (Vol. 28, No. 5,
                    pp. 307-316). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Writes via unchecked pointer dereferences rank
                            high among vulnerabilities most often exploited by
                            malicious code. The most common attacks use an
                            unchecked string copy to cause a buffer overrun,
                            thereby overwriting the return address in the
                            function's activation record. Then, when the
                            function "returns", control is actually
                            transferred to the attacker's code. Other attacks
                            may overwrite function pointers, setjmp buffers,
                            system-call arguments, or simply corrupt data to
                            cause a denial of service.A number of techniques
                            have been proposed to address such attacks. Some
                            are limited to protecting the return address only;
                            others are more general, but have undesirable
                            properties such as having a high runtime overhead,
                            requiring manual changes to the source code, or
                            forcing programmers to give up control of data
                            representations and memory management.This paper
                            describes the design and implementation of a
                            security tool for C programs that addresses all
                            these issues: it has a low runtime overhead, does
                            not require source code modification by the
                            programmer, does not report false positives, and
                            provides protection against a wide range of
                            attacks via bad pointer dereferences, including
                            but not limited to buffer overruns and attempts to
                            access previously freed memory. The tool uses
                            static analysis to identify potentially dangerous
                            pointer dereferences, and memory locations that
                            are legitimate targets of these pointers. Dynamic
                            checks are then inserted; if at runtime the target
                            of an unsafe dereference is not in the legitimate
                            set, a potential security violation is reported,
                            and the program is halted.
                        </div>
                    </span>
                </div>
                </li>
								<!-- <h2>Return Address Integrity</h2> -->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/dynaguard.pdf"
                            target="_blank">
                            DynaGuard: Armoring Canary-based
                            Protections against Brute-force Attacks (ASCAC
                            2015)
                        </a>
                    </div>
                    Theofilos Petsios, Vasileios P. Kemerlis, Michalis Polychronakis,
                    Angelos D. Keromytis. In Proceedings of the
                    31th Annual Computer Security Applications Conference (ACSAC),
                    December 2015.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Over the past decade many exploit mitigation techniques
                            have been introduced to defend against memory corruption
                            attacks. WˆX, ASLR, and canary-based protections are
                            nowadays widely deployed and considered standard practice.
                            However, despite the fact that these techniques have
                            evolved over time, they still suffer from limitations that
                            enable skilled adversaries to bypass them.
                            In this work, we focus on countermeasures against the
                            byte-by-byte discovery of stack canaries in forking
                            programs. This limitation, although known for years, has
                            yet to be ad- dressed effectively, and was recently abused
                            by a series of exploits that allowed for the remote
                            compromise of the popular Nginx web server and a full ASLR
                            bypass in x86-64 Linux. We present DynaGuard, an extension
                            to canary-based protections that further armors hardened
                            applications against brute-force canary attacks. We have
                            implemented DynaGuard in two flavors: a compiler-based
                            version, which incurs an average runtime overhead of 1.2%,
                            and a version based on dynamic binary instrumentation,
                            which can protect binary-only applications without
                            requiring access to source code. We have evaluated both
                            implementations using a set of popular server applications
                            and benchmark suites, and examined how the proposed design
                            overcomes the limitations of previous proposals, ensuring
                            application correctness and seamless integration with
                            third-party software.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="https://www.isoc.org/isoc/conferences/ndss/05/proceedings/papers/dira.pdf"
                            target="_blank">
												DIRA:
													Automatic Detection, Identification and Repair of
													Control-Hijacking Attacks (2005)
                        </a>
												Smirnov, A., & Chiueh, T. C. (2005, February).
													In NDSS.
                    </div>
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													Buffer overflow attacks are known to be the most
													common type of attacks that allow attackers to hijack
													a remote system by sending a specially crafted packet
													to a vulnerable network application running on it. A
													comprehensive defense strategy against such attacks
													should include (1) an attack detection component that
													determines the fact that a program is compromised and
													prevents the attack from further propagation, (2) an
													attack identification component that identifies
													attack packets so that one can block such packets in
													the future, and (3) an attack repair component that
													restores the compromised application’s state to that
													before the attack and allows it to continue running
													normally. Over the last decade, a significant amount
													of research has been vested in the systems that can
													detect buffer overflow attacks either statically at
													compile time or dynamically at run time. However, not
													much effort is spent on automated attack packet
													identification or attack repair. In this paper we
													present a unified solution to the three problems
													mentioned above. We implemented this solution as a
													GCC compiler extension called DIRA that transforms a
													program’s source code so that the resulting program
													can automatically detect any buffer overflow attack
													against it, repair the memory damage left by the
													attack, and identify the actual attack packet(s). We
													used DIRA to compile several network applications
													with known vulnerabilities and tested DIRA’s
													effectiveness by attacking the transformed programs
													with publicly available exploit code. The
													DIRA-compiled programs were always able to detect the
													attacks, identify the attack packets and most often
													repair themselves to continue normal execution. The
													average run-time performance overhead for attack
													detection and attack repair/identification is 4% and
													25 % respectively
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href=http://suif.stanford.edu/papers/tunji04.pdf
                            target="_blank">
											A Practical
											Dynamic Buffer Overflow Detector (2004)
                        </a>
											</div>
											Ruwase, O., & Lam, M. S. (2004, February).
											In NDSS.
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													Despite previous efforts in auditing software
													manually and automatically, buffer overruns are still
													being discovered in programs in use. A dynamic bounds
													checker detects buffer overruns in erroneous software
													before it occurs and thereby prevents attacks from
													corrupting the integrity of the system. Dynamic
													buffer overrun detectors have not been adopted widely
													because they either (1) cannot guard against all
													buffer overrun attacks, (2) break existing code, or
													(3) incur too high an overhead. This paper presents a
													practical detector called CRED (C Range Error
													Detector) that avoids each of these deficiencies.
													CRED finds all buffer overrun attacks as it directly
													checks for the bounds of memory accesses. Unlike the
													original referent-object based bounds-checking
													technique, CRED does not break existing code because
													it uses a novel solution to support program
													manipulation of out-of-bounds addresses. Finally, by
													restricting the bounds checks to strings in a
													program, CRED’s overhead is greatly reduced without
													sacrificing protection in the experiments we
													performed. CRED is implemented as an extension of the
													GNU C compiler version 3.3.1. The simplicity of our
													design makes possible a robust implementation that
													has been tested on over 20 open-source programs,
													comprising over 1.2 million lines of C code. CRED
													proved effective in detecting buffer overrun attacks
													on programs with known vulnerabilities, and is the
													only tool found to guard against a testbed of 20
													different buffer overflow attacks[34]. Finding
													overruns only on strings impose an overhead of less
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/rad.pdf"
                            target="_blank">
                        RAD: A
                        compile-time solution to buffer overflow attacks
                        (ICDS 2001)
                        </a>
                    </div>
                        Chiueh, T. C., & Hsu, F. H. (2001, April).
                        In
                        Distributed Computing Systems, 2001. 21st
                        International Conference on. (pp. 409-417). IEEE.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Buffer overflow attack can inflict upon almost
                            arbitrary programs and is one of the most common
                            vulnerabilities that can seriously compromise the
                            security of a network-attached computer system.
                            This paper presents a compiler-based solution to
                            the notorious buffer overflow attack problem.
                            Using this solution, users can prevent attackers
                            from compromising their systems by changing the
                            return address to execute injected code, which is
                            the most common method used in buffer overflow
                            attacks. Return address defender (RAD) is a simple
                            compiler patch that automatically creates a safe
                            area to store a copy of return addresses and
                            automatically adds protection code into
                            applications that it compiles to defend programs
                            against buffer overflow attacks. Using it to
                            protect a program does not need to modify the
                            source code of the protected programs. Moreover,
                            RAD does not change the layout of stack frames, so
                            binary code it generated is compatible with
                            existing libraries and other object files.
                            Empirical performance measurements on a fully
                            operational RAD prototype show that programs
                            protected by RAD only experience a factor of
                            between 1.01 to 1.31 slow-down. In this paper we
                            present the principle of buffer overflow attacks,
                            a taxonomy of defense methods, the implementation
                            details of RAD, and the performance analysis of
                            the RAD prototype
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/stackguard.pdf"
                            target="_blank">
                            StackGuard:
                            Automatic Adaptive Detection and Prevention of
                            Buffer-Overflow Attacks (USENIX 1998)
                        </a>
                    </div>
                    Cowan, C., Pu, C., Maier, D., Walpole, J., Bakke, P.,
                    Beattie, S., ... & Hinton, H. (1998, January).
                    In Usenix Security (Vol. 98, pp.
                    63-78).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            This paper presents a systematic solution to the
                            persistent problem of buffer overflow attacks.
                            Buffer overflow attacks gained notoriety in 1988
                            as part of the Morris Worm incident on the
                            Internet. While it is fairly simple to fix
                            individual buffer overflow vulnerabilities, buffer
                            overflow attacks continue to this day. Hundreds of
                            attacks have been discovered, and while most of
                            the obvious vulnerabilities have now been patched,
                            more sophisticated buffer overflow attacks
                            continue to emerge.
                            <br></br>
                            We describe StackGuard: a simple compiler
                            technique that virtually eliminates buffer
                            overflow vulnerabilities with only modest
                            performance penalties. Privileged programs that
                            are recompiled with the StackGuard compiler
                            extension no longer yield control to the attacker,
                            but rather enter a fail-safe state. These programs
                            require no source code changes at all, and are
                            binary-compatible with existing operating systems
                            and libraries. We describe the compiler technique
                            (a simple patch to gcc), as well as a set of
                            variations on the technique that trade-off between
                            penetration resistance and performance. We present
                            experimental results of both the penetration
                            resistance and the performance impact of this
                            technique.
                        </div>
                    </span>
                </div>
                </li>
								<!-- <h2>Pointer Integrity</h2> -->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/cpi.pdf"
                            target="_blank">
                            Code-pointer integrity (OSDI 2014)
                        </a>
                    </div>
                            Kuznetsov, V., Szekeres, L., Payer, M., Candea,
                            G., Sekar, R., & Song, D. (2014, October).
                            In USENIX Symposium on
                            Operating Systems Design and Implementation
                            (OSDI).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Systems code is often written in low-level
                            languages like C/C++, which offer many benefits
                            but also delegate memory management to
                            programmers. This invites memory safety bugs that
                            attackers can exploit to divert control flow and
                            compromise the system. Deployed defense mechanisms
                            (e.g., ASLR, DEP) are incomplete, and stronger
                            defense mechanisms (e.g., CFI) often have high
                            overhead and limited guarantees.
                            <br></br>
                            We introduce code-pointer integrity (CPI), a new
                            design point that guarantees the integrity of all
                            code pointers in a program (e.g., function
                            pointers, saved return addresses) and thereby
                            prevents all control-flow hijack attacks,
                            including return-oriented programming. We also
                            introduce code-pointer separation (CPS), a
                            relaxation of CPI with better performance
                            properties. CPI and CPS offer substantially better
                            security-to-overhead ratios than the state of the
                            art, they are practical (we protect a complete
                            FreeBSD system and over 100 packages like apache
                            and postgresql), effective (prevent all attacks in
                            the RIPE benchmark), and efficient: on SPEC
                            CPU2006, CPS averages 1.2% overhead for C and 1.9%
                            for C/C++, while CPI’s overhead is 2.9% for C and
                            8.4% for C/C++.
                            <br></br>
                            A prototype implementation of CPI and CPS can be
                            obtained from http://levee.epfl.ch.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://static.usenix.org/events/sec03/tech/full_papers/cowan/cowan_html/"
                            target="_blank">
                    Pointguard TM: protecting pointers from buffer
                    overflow vulnerabilities (USENIX 2003)
                        </a>
                    </div>
                    Cowan, C., Beattie, S., Johansen, J., & Wagle, P. (2003,
                    August).
                    In Proceedings of the 12th
                    conference on USENIX Security Symposium (Vol. 12, pp.
                    91-104).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Despite numerous security technologies crafted to
                            resist buffer overflow vulnerabilities, buffer
                            overflows continue to be the dominant form of
                            software security vulnerability. This is because
                            most buffer overflow defenses provide only partial
                            coverage, and the attacks have adapted to exploit
                            problems that are not well-defended, such as heap
                            overflows. This paper presents PointGuard, a
                            compiler technique to defend against most kinds of
                            buffer overflows by encrypting pointers when
                            stored in memory, and decrypting them only when
                            loaded into CPU registers. We describe the
                            PointGuard implementation, show that PointGuard's
                            overhead is low when protecting real
                            security-sensitive applications such as OpenSSL,
                            and show that PointGuard is effective in defending
                            against buffer overflow vulnerabilities that are
                            not blocked by previous defenses.
                        </div>
                    </span>
                </div>
                </li>
								<!-- <h2>Software Fault Isolation (SFI)</h2> -->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/likelysfi.pdf"
                            target="_blank">
                    Using likely invariants for automated software fault
                    localization (ASPLOS 2013)
                        </a>
                    </div>
                    Sahoo, S. K., Criswell, J., Geigle, C., & Adve, V. (2013).
                    ACM SIGARCH Computer Architecture News,
                    41(1), 139-152.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            We propose an automatic diagnosis technique for
                            isolating the root cause(s) of software failures.
                            We use likely program invariants, automatically
                            generated using correct inputs that are close to
                            the fault-triggering input, to select a set of
                            candidate program locations which are possible
                            root causes. We then trim the set of candidate
                            root causes using software-implemented dynamic
                            backwards slicing, plus two new filtering
                            heuristics: dependence filtering, and filtering
                            via multiple failing inputs that are also close to
                            the failing input. Experimental results on
                            reported software bugs of three large open-source
                            servers show that we are able to narrow down the
                            number of candidate bug locations to between 5 and
                            17 program expressions, even in programs that are
                            hundreds of thousands of lines long.
                        </div>
                    </span>
                </div>
								</li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/rocksalt.pdf"
                            target="_blank">
                    RockSalt: better, faster, stronger
                    SFI for the x86 (PLDI 2012)
                        </a>
                    </div>
                    Morrisett, G., Tan, G., Tassarotti, J., Tristan, J. B., &
                    Gan, E. (2012, June).
                    In ACM SIGPLAN Notices (Vol. 47, No. 6,
                    pp. 395-404). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Software-based fault isolation (SFI), as used in
                            Google's Native Client (NaCl), relies upon a
                            conceptually simple machine-code analysis to
                            enforce a security policy. But for complicated
                            architectures such as the x86, it is all too easy
                            to get the details of the analysis wrong. We have
                            built a new checker that is smaller, faster, and
                            has a much reduced trusted computing base when
                            compared to Google's original analysis. The key to
                            our approach is automatically generating the bulk
                            of the analysis from a declarative description
                            which we relate to a formal model of a subset of
                            the x86 instruction set architecture. The x86
                            model, developed in Coq, is of independent
                            interest and should be usable for a wide range of
                            machine-level verification tasks.
                        </div>
                    </span>
                </div>
                </li>
								<!-- <h2>Error Detection</h2> -->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/memorysanitizer.pdf"
                            target="_blank">
                    MemorySanitizer: fast detector of uninitialized memory use
                    in C++ (CGO 2015)
                        </a>
                    </div>
                    Stepanov, E., & Serebryany, K. (2015, February).
                    In Code Generation and Optimization (CGO), 2015
                    IEEE/ACM International Symposium on (pp. 46-55). IEEE.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            This paper presents MemorySanitizer, a dynamic
                            tool that detects uses of uninitialized memory in
                            C and C++. The tool is based on compile time
                            instrumentation and relies on bit-precise shadow
                            memory at run-time. Shadow propagation technique
                            is used to avoid false positive reports on copying
                            of uninitialized memory. MemorySanitizer finds
                            bugs at a modest cost of 2.5× in execution time
                            and 2× in memory usage; the tool has an optional
                            origin tracking mode that provides better reports
                            with moderate extra overhead. The reports with
                            origins are more detailed compared to reports from
                            other similar tools; such reports contain names of
                            local variables and the entire history of the
                            uninitialized memory including intermediate
                            stores. In this paper we share our experience in
                            deploying the tool at a large scale and
                            demonstrate the benefits of compile-time
                            instrumentation over dynamic binary
                            instrumentation.
                        </div>
                    </span>
                </div>
								</li>
								<!--
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/intflow.pdf"
                            target="_blank">
                    IntFlow: improving the
                    accuracy of arithmetic error detection using information
                    flow tracking (ACSAC 2014)
                        </a>
                    </div>
                    Pomonis, M., Petsios, T., Jee, K., Polychronakis, M., &
                    Keromytis, A. D. (2014, December).
                    In Proceedings of the 30th Annual Computer
                    Security Applications Conference (pp. 416-425). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Integer overflow and underflow, signedness
                            conversion, and other types of arithmetic errors
                            in C/C++ programs are among the most common
                            software flaws that result in exploitable
                            vulnerabilities. Despite significant advances in
                            automating the detection of arithmetic errors,
                            existing tools have not seen widespread adoption
                            mainly due to their increased number of false
                            positives. Developers rely on wrap-around
                            counters, bit shifts, and other language
                            constructs for performance optimizations and code
                            compactness, but those same constructs, along with
                            incorrect assumptions and conditions of undefined
                            behavior, are often the main cause of severe
                            vulnerabilities. Accurate differentiation between
                            legitimate and erroneous uses of arithmetic
                            language intricacies thus remains an open problem.
                            </br></br>
                            As a step towards addressing this issue, we
                            present IntFlow, an accurate arithmetic error
                            detection tool that combines static information
                            flow tracking and dynamic program analysis. By
                            associating sources of untrusted input with the
                            identified arithmetic errors, IntFlow
                            differentiates between non-critical, possibly
                            developer-intended undefined arithmetic
                            operations, and potentially exploitable arithmetic
                            bugs. IntFlow examines a broad set of integer
                            errors, covering almost all cases of C/C++
                            undefined behaviors, and achieves high error
                            detection coverage. We evaluated IntFlow using the
                            SPEC benchmarks and a series of real-world
                            applications, and measured its effectiveness in
                            detecting arithmetic error vulnerabilities and
                            reducing false positives. IntFlow successfully
                            detected all real-world vulnerabilities for the
                            tested applications and achieved a reduction of
                            89% in false positives over standalone static code
                            instrumentation.
                        </div>
                    </span>
                </div>
                </li>
								-->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/asan.pdf"
                            target="_blank">
                        AddressSanitizer: A Fast Address
                        Sanity Checker (USENIX 2012)
                        </a>
                    </div>
                        Serebryany, K., Bruening, D., Potapenko, A., & Vyukov,
                        D. (2012, June).
                        In USENIX Annual Technical Conference
                        (pp. 309-318).
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
                            Memory access bugs, including buffer overflows and
                            uses of freed heap memory, remain a serious
                            problem for programming languages like C and C++.
                            Many memory error detectors exist, but most of
                            them are either slow or detect a limited set of
                            bugs, or both.
                            <br></br>
                            This paper presents AddressSanitizer, a new memory
                            error detector. Our tool finds out-of-bounds
                            accesses to heap, stack, and global objects, as
                            well as use-after-free bugs. It employs a
                            specialized memory allocator and code
                            instrumentation that is simple enough to be
                            implemented in any compiler, binary translation
                            system, or even in hardware.
                            <br></br>
                            AddressSanitizer achieves efficiency without
                            sacrificing comprehensiveness. Its average
                            slowdown is just 73% yet it accurately detects
                            bugs at the point of occurrence. It has found over
                            300 previously unknown bugs in the Chromium
                            browser and many bugs in other software.
                        </div>
                    </span>
                </div>
                </li>
<!--
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.columbia.edu/~theofilos/files/papers/candidancy/bugsdeviant.pdf"
                            target="_blank">
											Bugs as deviant behavior: A general approach
											to inferring errors in systems code (SOSP 2001)
                        </a>
											</div>
											Engler, D., Chen, D. Y., Hallem, S., Chou, A., & Chelf,
											B. (2001).
											(Vol. 35, No. 5, pp.
											57-72). ACM.
                    <span class="abstract">
                        [abstract]
                        <div class="full_abstract">
											A major obstacle to finding program errors in a real
											system is knowing what correctness rules the system must
											obey. These rules are often undocumented or specified in
											an ad hoc manner. This paper demonstrates techniques that
											automatically extract such checking information from the
											source code itself, rather than the programmer, thereby
											avoiding the need for a priori knowledge of system
											rules.The cornerstone of our approach is inferring
											programmer "beliefs" that we then cross-check for
											contradictions. Beliefs are facts implied by code: a
											dereference of a pointer, p, implies a belief that p is
											non-null, a call to "unlock(1)" implies that 1 was
											locked, etc. For beliefs we know the programmer must
											hold, such as the pointer dereference above, we
											immediately flag contradictions as errors. For beliefs
											that the programmer may hold, we can assume these beliefs
											hold and use a statistical analysis to rank the resulting
											errors from most to least likely. For example, a call to
											"spin_lock" followed once by a call to "spin_unlock"
											implies that the programmer may have paired these calls
											by coincidence. If the pairing happens 999 out of 1000
											times, though, then it is probably a valid belief and the
											sole deviation a probable error. The key feature of this
											approach is that it requires no a priori knowledge of
											truth: if two beliefs contradict, we know that one is an
											error without knowing what the correct belief
											is.Conceptually, our checkers extract beliefs by
											tailoring rule "templates" to a system --- for example,
											finding all functions that fit the rule template "a must
											be paired with b." We have developed six checkers that
											follow this conceptual framework. They find hundreds of
											bugs in real systems such as Linux and OpenBSD. From our
											experience, they give a dramatic reduction in the manual
											effort needed to check a large system. Compared to our
											previous work [9], these template checkers find ten to
											one hundred times more rule instances and derive
											properties we found impractical to specify manually.
                        </div>
                    </span>
                </div>
								</li>
-->
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://llvm.org/pubs/2006-05-24-SAFECode-BoundsCheck.pdf"
                            target="_blank">
											Backwards-compatible array bounds checking for C with
											very low overhead (2006)
                        </a>
											</div>
											Dhurjati, D., & Adve, V. (2006, May).
											In Proceedings of the 28th
											international conference on Software engineering (pp.
											162-171). ACM.
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													The problem of enforcing correct usage of array and
													pointer references in C and C++ programs remains
													unsolved. The approach proposed by Jones and Kelly
													(extended by Ruwase and Lam) is the only one we know
													of that does not require significant manual changes
													to programs, but it has extremely high overheads of
													5x-6x and 11x-12x in the two versions. In this paper,
													we describe a collection of techniques that
													dramatically reduce the overhead of this approach, by
													exploiting a fine-grain partitioning of memory called
													Automatic Pool Allocation. Together, these techniques
													bring the average overhead checks down to only 12%
													for a set of benchmarks (but 69% for one case). We
													show that the memory partitioning is key to bringing
													down this overhead. We also show that our technique
													successfully detects all buffer overrun violations in
													a test suite modeling reported violations in some
													important real-world programs.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cse.lehigh.edu/~gtan/paper/cfiDataSandboxing.pdf"
                            target="_blank">
											Combining control-flow integrity and static analysis for
											efficient and validated data sandboxing (CCS 2011)
                        </a>
											</div>
											Zeng, B., Tan, G., & Morrisett, G. (2011, October).
											In Proceedings
											of the 18th ACM conference on Computer and communications
											security (pp. 29-40). ACM.
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													In many software attacks, inducing an illegal
													control-flow transfer in the target system is one
													common step. Control-Flow Integrity (CFI) protects a
													software system by enforcing a pre-determined
													control-flow graph. In addition to providing strong
													security, CFI enables static analysis on low-level
													code. This paper evaluates whether CFI-enabled static
													analysis can help build efficient and validated data
													sandboxing. Previous systems generally sandbox memory
													writes for integrity, but avoid protecting
													confidentiality due to the high overhead of
													sandboxing memory reads. To reduce overhead, we have
													implemented a series of optimizations that remove
													sandboxing instructions if they are proven
													unnecessary by static analysis. On top of CFI, our
													system adds only 2.7% runtime overhead on SPECint2000
													for sandboxing memory writes and adds modest 19% for
													sandboxing both reads and writes. We have also built
													a principled data-sandboxing verifier based on range
													analysis. The verifier checks the safety of the
													results of the optimizer, which removes the need to
													trust the rewriter and optimizer. Our results show
													that the combination of CFI and static analysis has
													the potential of bringing down the cost of general
													inlined reference monitors, while maintaining strong
													security.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.seclab.tuwien.ac.at/papers/gfree.pdf"
                            target="_blank">
											G-Free: defeating
											return-oriented programming through gadget-less binaries
											(ACSAC 2010)
                        </a>
											</div>
											Onarlioglu, K., Bilge, L., Lanzi, A., Balzarotti, D., &
											Kirda, E. (2010, December).
											In Proceedings of the 26th Annual Computer Security
											Applications Conference (pp. 49-58). ACM.
                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													Despite the numerous prevention and protection
													mechanisms that have been introduced into modern
													operating systems, the exploitation of memory
													corruption vulnerabilities still represents a serious
													threat to the security of software systems and
													networks. A recent exploitation technique, called
													Return-Oriented Programming (ROP), has lately
													attracted a considerable attention from academia.
													Past research on the topic has mostly focused on
													refining the original attack technique, or on
													proposing partial solutions that target only
													particular variants of the attack.

													In this paper, we present G-Free, a compiler-based
													approach that represents the first practical solution
													against any possible form of ROP. Our solution is
													able to eliminate all unaligned free-branch
													instructions inside a binary executable, and to
													protect the aligned free-branch instructions to
													prevent them from being misused by an attacker. We
													developed a prototype based on our approach, and
													evaluated it by compiling GNU libc and a number of
													real-world applications. The results of the
													experiments show that our solution is able to prevent
													any form of return-oriented programming.
                        </div>
                    </span>
                </div>
                </li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://www.cs.ncsu.edu/faculty/jiang/pubs/EUROSYS10.pdf"
                            target="_blank">
													Defeating return-oriented rootkits
													with return-less kernels (EUROSYS 2010)
													</a>
													Li, J., Wang, Z., Jiang, X., Grace, M., & Bahram, S.
													(2010, April).
													In Proceedings of the 5th
													European conference on Computer systems (pp.
													195-208). ACM.
											</div>

                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													Targeting the operating system (OS) kernel, kernel
													rootkits pose a formidable threat to computer systems
													and their users. Recent efforts have made significant
													progress in blocking them from injecting malicious
													code into the OS kernel for execution. Unfortunately,
													they cannot block the emerging so-called
													return-oriented rootkits (RORs). Without the need of
													injecting their own malicious code, these rootkits
													can discover and chain together "return-oriented
													gadgets" (that consist of only legitimate kernel
													code) for rootkit computation.

													In this paper, we propose a compiler-based approach
													to defeat these return-oriented rootkits. Our
													approach recognizes the hallmark of return-oriented
													rootkits, i.e., the ret instruction, and accordingly
													aims to completely remove them in a running OS
													kernel. Specifically, one key technique named return
													indirection is to replace the return address in a
													stack frame into a return index and disallow a ROR
													from using their own return addresses to locate and
													assemble return-oriented gadgets. Further, to prevent
													legitimate instructions that happen to contain return
													opcodes from being misused,we also propose two other
													techniques, register allocation and peephole
													optimization, to avoid introducing them in the first
													place. We have developed a LLVM-based prototype and
													used it to generate a return-less FreeBSD kernel. Our
													evaluation results indicate that the proposed
													approach is generic, effective, and can be
													implemented on commodity hardware with a low
													performance overhead.
                        </div>
                    </span>
                </div>
								</li>
                <li>
                <div class="paper">
                    <div class="papertitle">
                        <a
                            href="http://wenke.gtisc.gatech.edu/papers/aslrguard.pdf"
														target="_blank">
														ASLR-Guard:
														Stopping Address Space Leakage for Code Reuse
														Attacks (CCS 2015)
													</a>
														Kangjie Lu, Chengyu Song, Byoungyoung Lee, Simon P.
														Chung, Taesoo Kim, and Wenke Lee. 2015.
														In Proceedings of the 22nd ACM SIGSAC
														Conference on Computer and Communications Security
														(CCS '15). ACM, New York, NY, USA, 280-291.
											</div>

                    <span class="abstract">
                        [abstract]
												<div class="full_abstract">
													A general prerequisite for a code reuse attack is
													that the attacker needs to locate code gadgets that
													perform the desired operations and then direct the
													control flow of a vulnerable application to those
													gadgets. Address Space Layout Randomization (ASLR)
													attempts to stop code reuse attacks by making the
													first part of the prerequisite unsatisfiable.
													However, research in recent years has shown that this
													protection is often defeated by commonly existing
													information leaks, which provides attackers clues
													about the whereabouts of certain code gadgets. In
													this paper, we present ASLR-Guard, a novel mechanism
													that completely prevents the leaks of code pointers,
													and render other information leaks (e.g., the ones of
													data pointers) useless in deriving code address. The
													main idea behind ASLR-Guard is to render leak of data
													pointer useless in deriving code address by
													separating code and data, provide a secure storage
													for code pointers, and encode the code pointers when
													they are treated as data. ASLR-Guard can either
													prevent code pointer leaks or render their leaks
													harmless. That is, ASLR-Guard makes it impossible to
													overwrite code pointers with values that point to or
													will hijack the control flow to a desired address
													when the code pointers are dereferenced. We have
													implemented a prototype of ASLR-Guard, including a
													compilation toolchain and a C/C++ runtime. Our
													evaluation results show that (1) ASLR-Guard supports
													normal operations correctly; (2) it completely stops
													code address leaks and can resist against recent
													sophisticated attacks; (3) it imposes almost no
													runtime overhead (< 1%) for C/C++ programs in the
													SPEC benchmark. Therefore, ASLR-Guard is very
													practical and can be applied to secure many
													applications.
                        </div>
                    </span>
                </div>
								</li>
		</ol>
	</div>
    </div> <!-- /publications -->
</div>
<br></br>
<br></br>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44431425-1', 'columbia.edu');
  ga('send', 'pageview');
</script>
</body>
</html>
